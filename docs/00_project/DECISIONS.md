# DECISIONS.md

## 목적
이 문서는 프로젝트 진행 중 중요한 설계/구현 의사결정을 기록합니다.

왜 이 구조를 선택했는지 남겨두면,
- 새 대화/새 세션에서 맥락 복구가 쉬워지고
- AI가 임의로 설계를 바꾸는 것을 방지하고
- 나중에 되돌리거나 개선할 때 근거가 됩니다.

---

## 기록 규칙
- 중요한 결정만 기록 (사소한 UI 문구 변경 제외)
- "무엇을", "왜", "대안", "영향"을 함께 기록
- 결정이 바뀌면 기존 항목을 지우지 말고 "변경 결정"으로 추가
- 관련 문서/파일 링크를 함께 남기기

---

## 템플릿
```md id="4drd7y"
## [DEC-XXX] 결정 제목
- 날짜: YYYY-MM-DD
- 상태: 제안 / 승인 / 보류 / 폐기 / 대체됨
- 결정자: (사용자 / AI 제안 / 공동)
- 관련 문서:
  - `docs/...`
- 관련 파일:
  - `frontend/...`
  - `backend/...`

### 배경
(왜 이 결정을 해야 했는지)

### 결정 내용
(무엇을 어떻게 하기로 했는지)

### 이유
(왜 이 선택을 했는지, 기대 효과)

### 고려한 대안
1. 대안 A
   - 장점:
   - 단점:
2. 대안 B
   - 장점:
   - 단점:

### 영향 범위
- 프론트:
- 백엔드:
- 데이터/캐시:
- 운영/비용:

### 후속 작업
- [ ] 작업 1
- [ ] 작업 2

### 비고
(주의사항, 추후 재검토 조건 등)


의사결정 목록
[DEC-001] 코딩 전 문서 하니스(매뉴얼/기억/품질검사) 먼저 세팅

날짜: 2026-02-23

상태: 승인

결정자: 공동

관련 문서:

AGENT.md

SKILLS.md

docs/00_project/PLAN.md

docs/00_project/CONTEXT_NOTE.md

docs/00_project/CHECKLIST.md

관련 파일:

(문서 작업 단계, 코드 파일 없음)

배경

대화가 길어질수록 AI가 앞선 맥락과 설계 의도를 잊는 문제가 반복될 수 있음.
코딩부터 시작하면 속도는 빠르지만 구조가 흔들리고 누락/재작업 가능성이 커짐.

결정 내용

코딩 전에 다음 시스템을 먼저 세팅한다.

매뉴얼 시스템 (AGENT.md, docs/01_manuals/*)

작업 기억 시스템 (PLAN, CONTEXT_NOTE, CHECKLIST)

품질검사 시스템 (qa-checklist, done-report, peer-review)

이유

세션 변경 시 복구 속도 향상

설계 의도 유지

작업 누락 감소

AI 산출물 품질 안정화

고려한 대안

바로 코드 구현 시작

장점: 초기 속도 빠름

단점: 중간에 맥락 붕괴/재작업 위험 높음

문서 최소화 (README만 작성)

장점: 문서 작업 부담 적음

단점: 도메인별 규칙/품질 기준 누락 가능성 큼

영향 범위

프론트: 상태 설계/타입 규칙 문서화 선행

백엔드: API 계약/예외 처리 규칙 선행

데이터/캐시: 버전/캐시 전략 사전 합의 가능

운영/비용: AI 호출 비용 보호 정책 반영 가능

후속 작업

 핵심 문서 템플릿 생성

 도메인 매뉴얼 분리

 스키마/샘플 출력 문서화

 코드 구현 단계 진입

비고

문서 작업이 과도하게 길어지지 않도록, 이후부터는 기능 단위로 문서와 코드를 함께 업데이트한다.

[DEC-002] 기술 스택 기본 조합: React(Vite) + FastAPI + Gemini

날짜: 2026-02-23

상태: 승인

결정자: 공동

관련 문서:

SKILLS.md

docs/00_project/PLAN.md

docs/00_project/CONTEXT_NOTE.md

관련 파일:

(초기 구조 생성 전)

배경

AI 친화적인 스택(문서/예제가 많고 구현 속도가 빠른 조합)이 필요함.
또한 사용자 선호상 Gemini API 우선 사용 정책이 있음.

결정 내용

초기 MVP 기준 스택을 아래로 고정한다.

Frontend: React + Vite + TypeScript + Tailwind

Backend: FastAPI + Pydantic

AI: Gemini API

DB: PostgreSQL (초기 mock 가능)

이유

AI가 비교적 안정적으로 코드 생성 가능

프론트/백엔드 역할 분리 명확

이후 확장(배포, 캐시, 큐) 용이

고려한 대안

Next.js + FastAPI

장점: SSR/라우팅 구조 강력

단점: 초기 MVP에서 구조 복잡도 증가 가능

단일 백엔드 렌더링 앱

장점: 빠른 프로토타입

단점: UI/상태 복잡도 증가 시 유지보수 불리

영향 범위

프론트: TS 타입 우선 설계 가능

백엔드: Pydantic 기반 API 계약 문서화 용이

데이터/캐시: Redis/Postgres 확장 구조 쉬움

운영/비용: 프론트/백 분리 배포 가능

후속 작업

 폴더 구조 생성

 API 계약 문서 기준 타입/스키마 생성

 분석 모달 MVP 구현

비고

향후 필요 시 Next.js로 전환 가능하지만, 초기 MVP에서는 구현 속도와 안정성을 우선한다.

[DEC-003] AI 소재 분석 API는 Job 기반 확장 가능한 계약으로 시작

날짜: 2026-02-23

상태: 승인

결정자: 공동

관련 문서:

docs/01_manuals/api-contracts.md

docs/01_manuals/backend.md

docs/01_manuals/frontend.md

docs/01_manuals/data.md

관련 파일:

(구현 전)

배경

댓글 수집 + AI 분석은 처리 시간이 길어질 수 있음.
초기에는 동기 방식으로 구현할 수 있으나, UI는 이미 "분석중 → 완료" 흐름을 사용함.

결정 내용

API 계약은 jobId + status polling 구조를 기준으로 설계한다.
초기 구현이 동기 처리여도, 응답 구조는 Job 기반으로 맞춘다.

이유

프론트 UX(로딩 모달)와 자연스럽게 연결됨

나중에 비동기 워커/큐 도입 시 변경 비용 감소

실패/재시도/진행 단계 표현이 쉬움

고려한 대안

완전 동기 API만 사용

장점: 구현 단순

단점: 처리 시간 증가 시 UX/타임아웃 문제

처음부터 큐/워커/웹소켓 풀세팅

장점: 확장성 높음

단점: 초기 개발 속도 저하, 과설계 가능성

영향 범위

프론트: 폴링 상태 전환 구조 필요

백엔드: job 상태 저장/조회 구조 필요

데이터/캐시: analysis_jobs 개념 도입

운영/비용: 중복 실행 제어 여지 확보

후속 작업

 output-schema-analysis.json 확정

 분석 API Pydantic 스키마 작성

 프론트 모달 상태 타입 작성

비고

초기 MVP에서는 실제 큐가 없어도 무방. 단, 계약 구조는 유지한다.

[DEC-004] AI 분석 결과는 JSON 스키마 검증 후 저장

날짜: 2026-02-23

상태: 승인

결정자: 공동

관련 문서:

docs/01_manuals/ai-analysis.md

docs/01_manuals/api-contracts.md

docs/01_manuals/data.md

docs/03_prompts/output-schema-analysis.json

관련 파일:

scripts/validate_ai_output.py (예정)

배경

AI 자유출력은 필드 누락/형식 깨짐이 발생하기 쉬움.
프론트 UI는 구조화된 필드에 의존하므로 자유 텍스트 저장은 위험함.

결정 내용

Gemini 응답은 반드시:

JSON 파싱

스키마 검증

필요 시 보정

그 후 저장
순서를 거친다.

이유

프론트 렌더링 안정성 확보

캐시 품질 유지

장애 원인 추적 용이

고려한 대안

자유 텍스트 저장 후 프론트에서 파싱

장점: 구현 빠름

단점: 실패율 높고 유지보수 어려움

스키마 검증 없이 바로 저장

장점: 초기 속도 빠름

단점: 캐시 오염 위험 큼

영향 범위

프론트: 필드 신뢰도 증가

백엔드: 검증/보정 로직 필요

데이터/캐시: 저장 품질 향상

운영/비용: 실패 재시도 정책 필요

후속 작업

 출력 스키마 파일 생성

 샘플 출력 JSON 작성

 검증 스크립트 추가

비고

보정 규칙은 문서화된 범위 내에서만 허용하고 의미 왜곡은 금지한다.



[DEC-005] YouTube API v3는 Render 백엔드 프록시로만 호출

날짜: 2026-03-13

상태: 승인

결정자: 공동

관련 문서:

docs/01_manuals/backend.md

docs/01_manuals/api-contracts.md

docs/01_manuals/security.md

docs/00_project/CHECKLIST.md

관련 파일:

(문서 정책 확정 단계, 코드 변경 없음)

배경

유튜브 검색 기능은 YouTube API v3 키가 필요하고, 프론트 직호출 시 키 노출/남용/비용 급증 위험이 큼.
또한 quota 초과/상류 장애를 프론트에서 일관되게 처리하기 어려워 API 계약 고정이 필요함.

결정 내용

YouTube API v3 호출은 Render 백엔드에서만 수행한다.

`YOUTUBE_API_KEY`는 서버 환경변수로만 관리하고 프론트(`VITE_*`)에는 저장하지 않는다.

프론트는 `/api/search/videos`만 호출하고, 백엔드는 공통 에러코드(`SEARCH_QUOTA_EXCEEDED`, `SEARCH_RATE_LIMITED`, `SEARCH_UPSTREAM_UNAVAILABLE`, `SEARCH_UPSTREAM_ERROR`)로 변환해 반환한다.

검색 요청은 dedupe + 캐시 우선 정책으로 중복 외부 호출을 억제한다.

이유

키 보안 강화 및 오남용 방지

quota/장애 상황에서 일관된 사용자 경험 제공

캐시/중복 방지로 비용과 지연을 줄이고, 추후 Firestore 연동 시 read 소모 증가 위험 완화

고려한 대안

프론트에서 YouTube API 직접 호출

장점: 초기 구현 단순

단점: 키 노출 위험, 호출 통제 어려움, 비용 보호 취약

서드파티 검색 API 우선 사용

장점: 구현 속도 가능

단점: 데이터/정확도/정책 의존성 증가, 장기 운영 리스크

영향 범위

프론트: 백엔드 검색 API만 연동, 키 비노출 보장

백엔드: YouTube 연동/timeout/에러매핑/dedupe 책임 증가

데이터/캐시: 검색 캐시 키/TTL 정책 필요

운영/비용: 키 관리 단순화, quota 대응 명확화

후속 작업

 [ ] FE-4 popstate 동기화에서 자동 재조회 조건을 최소화

 [ ] 백엔드 검색 라우터 구현 시 에러코드/메시지 계약 준수 테스트 추가

비고

Firestore가 주 저장소로 확정되면, 동일 dedupe/캐시 원칙을 읽기 경로에도 일관 적용한다.
