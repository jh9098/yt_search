# security.md

## 목적
이 문서는 API 키/비밀정보 관리, 입력 검증, 로그 마스킹, CORS, 남용 방지 등
기본 보안/운영 안정성 규칙을 정의합니다.

초기 MVP라도 외부 API(Gemini, 유튜브 데이터 소스)를 사용하므로,
보안/비용/장애 관점의 최소 기준을 반드시 적용합니다.

---

## 핵심 원칙
1. **비밀정보는 코드에 하드코딩하지 않는다**
2. **입력값은 항상 검증한다**
3. **로그에 민감정보를 남기지 않는다**
4. **외부 API 호출 실패를 정상 흐름으로 처리한다**
5. **과도한 요청/중복 요청을 통제한다**
6. **프론트에 불필요한 내부 정보 노출 금지**

---

## 비밀정보 관리 (Secrets)

### 절대 금지
- API 키를 Git 저장소에 커밋
- 프론트 코드에 서버용 비밀키 노출
- 에러 응답/로그에 원문 키 출력
- `.env` 파일을 공유/업로드

### 권장
- 서버 환경변수(`.env`) 사용
- `.env.example`에는 키 이름만 제공 (값 없음)
- 키 로딩 실패 시 서버 시작 단계에서 명확히 에러 처리
- 운영/개발 환경 키 분리

---

## `.env.example` 예시 필드 (개념)
아래는 예시이며 실제 값은 넣지 않습니다.

- `APP_ENV=development`
- `APP_PORT=8000`
- `DATABASE_URL=...`
- `REDIS_URL=...`
- `GEMINI_API_KEY=...`
- `YOUTUBE_API_KEY=...` (공식 API 사용 시)
- `ALLOWED_ORIGINS=http://localhost:5173`

주의:
- 프론트 빌드 시 노출 가능한 환경변수와 서버 전용 환경변수를 구분해야 함

---

## 프론트/백엔드 비밀정보 경계
### 원칙
- Gemini API 호출은 가능하면 백엔드에서 수행
- 서버 전용 키는 절대 프론트로 전달하지 않음
- 프론트는 백엔드 API만 호출

### 이유
- 키 탈취 위험 감소
- 요청량/비용 통제 가능
- 캐시/중복 방지 적용 가능
- 응답 스키마 표준화 가능

---

## 입력 검증 규칙 (중요)
모든 API 입력값은 검증 대상입니다.

### 필수 검증 항목 예시
- `videoId` 존재 여부
- 문자열 길이 제한
- boolean 파라미터 타입 검증 (`forceRefresh`)
- path param 형식 검증 (`jobId`)
- 검색 키워드 길이/문자 제한 (추후)

### 검증 원칙
- 잘못된 요청은 빠르게 실패 (`400` 계열)
- 사용자 메시지는 친절하게
- 내부 검증 실패 상세는 서버 로그에 남김

---

## 출력/응답 정보 노출 최소화
프론트 응답에는 다음을 노출하지 않습니다.
- stack trace
- 내부 파일 경로
- DB 쿼리 원문
- 외부 API 원문 에러 전체
- 비밀키/토큰/헤더

프론트에는 필요한 수준만 전달:
- 에러 코드
- 사용자 메시지
- 재시도 가능 여부(필요 시)
- requestId(문제 추적용)

---

## 로그 마스킹 규칙
### 로그에 남겨도 되는 것
- `requestId`, `jobId`
- 엔드포인트
- 처리시간
- 상태 전환
- 성공/실패 요약
- 에러 코드

### 로그에 남기면 안 되는 것
- API 키
- Authorization 헤더
- 세션 토큰
- 댓글 원문 대량 덤프
- 프롬프트 전문(민감/비용/저작권 이슈 가능)
- 개인정보로 해석될 수 있는 원문 데이터 (정책에 따라 제한)

### 권장
- 민감정보 마스킹 함수 공용화
- 에러 로깅 시 `safe_message` 사용

---

## 외부 API 호출 보안/안정성 규칙
### 필수
- timeout 설정
- 예외 처리
- 실패 시 사용자 친화 에러 변환
- rate limit / quota 초과 감지
- 재시도 횟수 제한 (무한 재시도 금지)

### 권장
- 요청당 비용이 큰 API는 캐시 우선 조회
- 동일 요청 중복 실행 방지 (job dedupe)
- 외부 API 응답 검증 (형식/필수값 확인)

---

## CORS 정책 (초기)
개발 환경에서는 필요한 origin만 허용하고, 운영 시 더 엄격하게 설정합니다.

### 원칙
- `*` 전체 허용 최소화 (특히 credentials 사용 시 금지)
- 개발/운영 origin 분리
- 허용 메서드/헤더 최소화 가능하면 적용

예시(개념):
- 개발: `http://localhost:5173`
- 운영: 실제 프론트 도메인만 허용

---

## 남용 방지 / 비용 보호 규칙 (초기 중요)
AI 분석 기능은 비용이 발생할 수 있으므로 최소한의 보호 장치를 둡니다.

### 초기 권장
- 동일 영상 분석 요청 dedupe (진행 중 job 재사용)
- 캐시 재사용 기본값 (`forceRefresh=false`)
- 요청 간 최소 쿨다운(추후)
- IP/사용자 단위 rate limit(추후)
- 긴 분석 실패 시 재시도 제한

### 중복 요청 처리 예시
- 같은 `videoId`로 동일 버전 분석이 이미 `processing`이면
  - 새 job 생성 대신 기존 jobId 반환 (정책 선택)

---

## 에러 메시지 정책
### 사용자 메시지
- 이해 가능
- 재시도 가능 여부를 암시
- 내부 정보 노출 없음

예:
- "분석 중 오류가 발생했습니다. 잠시 후 다시 시도해 주세요."
- "입력값이 올바르지 않습니다."
- "분석 요청이 많아 지연되고 있습니다. 잠시 후 다시 시도해 주세요."

### 내부 로그 메시지
- 원인 추적 가능
- 민감정보 제거
- 코드/상태 포함

예:
- `ANALYSIS_TIMEOUT: Gemini call timed out after 20s (jobId=...)`

---

## 데이터 저장 시 보안/정책 고려
### 원칙
- 필요 최소 데이터만 저장
- 저장 목적(캐시/디버깅/통계) 구분
- 원문 장기 저장 필요성 검토
- 개인정보/민감정보 가능성 있는 필드는 신중 처리

### ChatGPT의 의견
초기에는 댓글 원문 전체 장기보관보다, 샘플 수/키워드/요약 결과 중심 저장이 운영 부담과 리스크를 줄이기 좋습니다.

---

## 운영/배포 기본 체크 (초기)
- [ ] `.env`가 `.gitignore`에 포함됨
- [ ] 운영 환경변수 설정 확인
- [ ] CORS origin 운영 도메인만 허용
- [ ] 디버그 모드 비활성화 (운영)
- [ ] 에러 응답에 stack trace 미노출
- [ ] 로그에 민감정보 마스킹 적용
- [ ] timeout 설정 적용
- [ ] 분석 중복 요청 처리 정책 확인

---

## 사고 대응 최소 규칙 (초기 버전)
문제 발생 시 아래를 먼저 확인:
1. 외부 API quota/rate limit
2. 환경변수 누락/변경
3. 최근 배포에서 응답 스키마 변경 여부
4. JSON 스키마 검증 실패 급증 여부
5. 캐시/DB 저장 실패 여부

권장:
- `requestId` 기준으로 로그 추적
- 실패 유형을 `failure-log.md`에 누적 기록

---

## 변경 시 문서 동기화 규칙
다음 변경 시 함께 수정:
- 에러 코드/메시지 정책 변경 → `api-contracts.md`
- 외부 API 호출 방식 변경 → `backend.md`, `ai-analysis.md`
- 저장 정책 변경 → `data.md`
- 운영 보안 정책 강화 → `CONTEXT_NOTE.md` (핵심 의사결정일 경우)

---

## 확실하지 않은 사실 / ChatGPT의 의견
- 확실하지 않은 사실: 댓글/메타데이터 저장 범위에 대한 최종 정책은 실제 데이터 수집 방식 및 서비스 운영 정책에 따라 달라질 수 있음
- ChatGPT의 의견: 초기 MVP에서도 `timeout + 입력검증 + 로그마스킹 + 캐시우선` 4가지는 필수로 적용하는 것이 개발 속도 대비 효과가 가장 큼
